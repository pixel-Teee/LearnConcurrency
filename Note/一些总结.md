# mutex

mutex有lock和unlock成员函数，但是应当使用lock_guard进行构造，使用RAII机制来保证解锁。



通过返回指针和引用，会离开mutex的保护，从而导致威胁的行为，或者传入一个回调函数，这个回调函数获取到了数据的指针或者引用，在后续的操作中，对这个数据的指针和引用进行了修改。



接口的设计也会导致问题，比如stack的empty和top之间，另一个线程也尝试push一个元素到容器内，一个方法是top里面元素为的空的时候，抛出一个异常。因为这两个接口存在依赖关系。



合并这两个操作，也有问题，会爆内存，如果是一个stack&lt;vector&lt;int&gt;>，当拷贝vector的时候，会超出内存限制。



两种解决方法，第一种，就是：

pop接受一个参数的引用(这样两个操作就合并了)，但是缺点就是要在外面构造一个实例，还要求这个元素必须是可赋值的。



第二种则是不抛出异常的拷贝构造或者移动构造。



第三种，返回一个指针到弹出的元素，使用shared_ptr。



线程安全的栈，接口从empty和pop变成如下的接口：

```c++
std::shared_ptr<T> pop();
void pop(T& value);
```



这两个操作，如果栈为空的话，就抛出异常。



用mutex锁定同个实例的时候，可能会产生死锁。

C++标准库，提供std::lock，一个函数，可以**同时**锁定两个或者多个mutex的同时，而且没有死锁。

一次性，锁定两个mutex，std::lock_guard进行解锁，但是需要std::adopt_lock指示它不要加锁。









